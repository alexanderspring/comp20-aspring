<!DOCTYPE HTML> 
<html>
	<head>
		<title>Security Assesment</title>
		<meta name="viewport" content="initial-scale=1.0, user-scalable=no" />
		<meta charset="utf-8">
		<link rel="stylesheet" href="style.css" />
	</head>
	<body>
	<h1> Server Side Security Assesment </h1>
		<p>
			<span class="author"> Conducted by Alexander Spring
		</p>
	<h2> Introduction </h2>
		<p> 
			This security assesment describes the web security flaws of the MapChat application server created by Ming Chow for the Tufts University Fall <br> 2015 Web Programming course. The server was deployed by using Heroku, Node.js with the Express web framework, and MongoDB. <br> The application recieves check-ins from a set of approved logins. A check-in consists of a login, latitude, longitude, and a message. <br>
		</p>
		<p>
			The flaws discussed in this assesment were determined by their level of threat to both the longevity of the developer's application, the <br>threat to the functionality of the server, as well as the threat to the client and other clients privacy. <br>
		</p>
	<h2> Methodology </h2>
		<p>
			First the server was deployed to a new Heroku app with MongoLab installed. The code was not analyzed until "black box" testing was carried <br>out. Most of the security flaws were found without examining the server code. Eventually the code was reviewed and further faults <br> were exposed.
		</p>

	<h2> Abstract of Findings </h2>
		<p>
			The findings can be broken into three categories:
			<ul>
				<li> Exposure of information to those who shouldnt have access
				<li> Database limitations and server volunerabilities 
				<li> Enabled cross site scripting (XSS)
			</ul>
		</p>

	<h2> Issues Found </h2>
		<p> <span class="subheaders"> Cross Site Scripting (XSS)
			<ul>
				<li>Problem <br> 
				XSS occurs when scripts are maliciously embedded in a page that are executed on the client-side (in the user’s web browser) rather than on the server-side. Unfortunetly, the ability for the user to determine their own message allows for the insertion of a <code> script </code> tag in the message. Here, the google plugin Postman was used to insert script into the client side of the application. The injected script was used to produce a simple alert popup. However, someone with malicious intent could inject script which steals the clients information, corrupts the browser, and so on.
					<div id="images">
						<img src="insert_script.png" alt="how script was inserted"/>
					</div>
					<div id="images">
						<img src="xss.png" alt="popup"/>
					</div>
				<li>Possible Resolutions <br> 
				It is vital that when reading in a user's check-in information, any tags are sanitized upon reading in the data. This can be acomplished by using HTML encoding to encode the characters in the message. In this instance, <code> &lt;script&gt; </code> becomes 
				<code> &amp;gt;script&amp;gt; </code>
			</ul>
		</p>
		<p> <span class="subheaders"> Limitations of MongoDB
			<ul>
				<li>Problem: MongoDB Opperators Allow For Privacy Violations <br>
				When sending the <code> GET </code> request <code> /latest.json?login=mchow </code> the application is supposed to return the last check-in of the specified login, in this case mchow. If no login exists, the application should return <code> {} </code> <br>
				When sending the request <code> /latest.json?login[$ne]=my_login </code> the application returns the last login in the database that is not the specified login. In this case executing <code> /latest.json?login[$ne]=mchow </code> returned my login, <code> JoshRamsey </code><br>
				<img src="mongo_opperators.png"  alt="privacy breech"/>

				Since we are using the Mongo Database, the mongo operators can be used to return data that should not be returned. In this case, <code> $ne </code> selects the documents where the value of the field is not equal (i.e. !=) to the specified value. This includes documents that do not contain the field. This exposes the private information of one client to another client. If the database was storing credit card or other sensitive information this could be catestrophic. 
				<li>Possible Resolutions <br>
				Again, an attempt at sanitation should be made. Additionally, another database may be used to ileviate this issue. The Mongo documentation should be reviewed as well to see if there is a way to strip the client of the ability to manipulate the database with operators. <br> <br>
				<li>Problem: MongoDB Has Limited Functional Capacity <br>
				This next security flaw is more theoretical but can indeed be achieved. There is nothing in the server code that limits the number of check-ins from a given login. This means that a client could overload the database with check-ins. This may cause the server to crash or even worse, incur a charge on Heroku. The biggest issue here is that if malicous script existed, it could be injected rapidly. 

				Its quite hard to test this since computing reseources were limtied. In an attempt to achieve some significant result, the use of Amazon Web Services (AWS) was used. Specifically, the Amazon Elastic Compute Cloud (Amazon EC2) service was used. This services is a web service that "provides resizable compute capacity in the cloud." <br><br> Amazon describes their services as: 
					<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Amazon EC2’s simple web service interface allows you to obtain and configure capacity with minimal <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;friction. It provides you with complete control of your computing resources and lets you run on Amazon’s <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;proven computing environment. Amazon EC2 reduces the time required to obtain and boot new server <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instances to minutes, allowing you to quickly scale capacity, both up and down, as your computing requirements change <br> <br>
					<img src="amazon_web.png" alt="AWS"/>

				With the creation of a bash script which will cause infinte injections into the data base running on Amazon's server, an attempt was made at filling/overloading the database. The bash script consisted of an infinite loop which curled in data to the database.
				<img src="bash_script.png" alt="bash script used for rapid insertion"/>
				The script was then uploaded to the Amazon server and executed. The result was rapid insertion of data (rate of ~150/minute)
				<img src="amazon_web_shell.png" alt="aws command line"/>
				<img src="rapid_insertion.png" alt="lots of data"/>
				Upon review, the script used almost 20% of the alloted server CPU. Though the server was shut down after two minutes to avoid fees by Amazon or Heroku, it is very plausable that if the script continued to execute and use more CPU the database may have been affected. Further tests should be performed to test this hypothesis.
				<img src="amazon_cpu.png" alt="graph of server CPU"/>
			</ul>
		</p>
		<p> <span class="subheaders"> Setting Response Headers
			<ul>
				<li>Problem <br>
				Define CORS and SOP
				By responding with Access-Control-Allow-Origin: * the requested resource allows sharing with every origin. This basically means that any site can send a XHR request to your site and access the server’s response which would not be the case if you hadn’t implemented this CORS response.

				So any site can make a request to your site in behalf of their visitors and process the response of it. If you have something implemented like an authentication or authorization scheme that is based on something that is automatically provided by the browser (cookies, cookie-based sessions, etc.), the requests triggered by the third party sites will use them, too.

				This indeed poses a security risk, particularly if you allow resource sharing not just for selected resources but for every resource. In this context you should have a look at When is it safe to enable CORS?.


			</ul>
		</p>

	<h2> Conclusion </h2>
	The server code does not attempt to santizie data or limit the number of checkins. The use of mongo 

	</body>
</html>
